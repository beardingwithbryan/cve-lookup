''' 
CVE Query Script
Author: Joseph Harrietha + Bryan Beard
Last Updated 2022-04-23

Notes on Rate Limit:
  Requesting an API key allows for users to make a greater number of requests in a given time than they could otherwise.
  The public rate limit (without an API key) is 10 requests in a rolling 60 second window; 
  The rate limit with an API key is 100 requests in a rolling 60 second window.
  It is also recommended that users "sleep" their scripts for six seconds between requests.

# API Key: 5c3b11f5-bd44-4132-90b1-c354381bfdcb 
'''
# Imports
from ast import Or
import requests
import argparse
import json
import jsonlines
import pprint
import re
import time
import yaml
import csv
#import pandas

# Constants and Arguments
nvd_url = 'https://services.nvd.nist.gov/rest/json/cve/1.0/'
nvd_key = '5c3b11f5-bd44-4132-90b1-c354381bfdcb' 
r7_url = 'https://vdb.rapid7.com/'
sleepTime = 6.0/10.0

parser = argparse.ArgumentParser()

parser.add_argument("-i", "--input", required=True,  help="Input File, CVE on newline")
parser.add_argument("-o", "--output",  help="Output File, YAML or CSV")

args = parser.parse_args()

# Functions
def cve_query(cve_id):
    """
    Requests to the API. This function gathers information from the 
    NVD NIST and Rapid7 APIs abouteach CVEs and returns the data from
    each API in JSON format.
    """
    cves = {}
    nvd_params = {'apiKey': nvd_key, 'addOns': None}
    nvd_response = requests.get(nvd_url + cve_id, params=nvd_params)

    r7_params = {'query': cve_id, 'type': 'metasploit'}
    r7_response = requests.get(r7_url + 'v1/search', params=r7_params)
   
    

    return nvd_response.json(),r7_response.json()

def parse_nvd(nvd_raw):
    """
    This function parses through the large amount of data from NVD NIST
    for each CVE, specifically looking for the CVSS score (3 if it exists, 
    2 if it doesn't),number of existing exploits and their URLs. Returns a 
    dictionary object containing the CVE, Score, Exploit URL list, Number of Exploits,
    Yeaar and Number of CVE. Number of exploits, Year and Number values are used for sorting
    in the CVEs.
    """
    nvd_parsed = {}
    ref_ctr = 0
    exploit_urls = []

    nvd_parsed["CVE"] = nvd_raw["result"]["CVE_Items"][0]["cve"]["CVE_data_meta"]["ID"]
    year = re.search("(-[^-]*-)", nvd_parsed["CVE"]).group(0)
    year = year[1:-1]
    nvd_parsed['Year'] = int(year)
    num = re.search("(-[^-]*$)", nvd_parsed["CVE"]).group(0)
    num = num[1:]
    nvd_parsed['Number'] = int(num)
    #Check if scored in CVSSv3, if not there is only a CVSSv2 score
    if "baseMetricV3" in nvd_raw["result"]["CVE_Items"][0]["impact"]:
        nvd_parsed['Score'] = float(nvd_raw["result"]["CVE_Items"][0]["impact"]["baseMetricV3"]["cvssV3"]["baseScore"])
        nvd_parsed['Metric'] = "CVSSv3"
    else:
        nvd_parsed["Score"] = float(nvd_raw["result"]["CVE_Items"][0]["impact"]["baseMetricV2"]["cvssV2"]["baseScore"])
        nvd_parsed['Metric'] = "CVSSv2"
    
    for reference in nvd_raw["result"]["CVE_Items"][0]["cve"]["references"]["reference_data"]:
        if reference['refsource'] == 'EXPLOIT-DB' or "Exploit" in reference['tags']:
            exploit_urls.append(reference['url'])
        ref_ctr +=1
    nvd_parsed['Exploit_URLs'] = exploit_urls
    nvd_parsed['Number_of_Exploits'] = len(exploit_urls)
    ref_ctr = 0 
    exploit_urls = []  
    return nvd_parsed
    
    

def parse_r7(r7_raw):
    """
    This function parses through the information returned from the Rapid 7
    API looking to see if any MetaSploit modules exist. The function returns a dictionary 
    object with the module information. If a module exists, the MetaSploit
    Identifier (path in the MetaSploit Console) is parsed. If not, the dictionary
    object returns a value of "None".
    """
    
    r7_parsed = {}
    module_ctr = 0

    #Check if data exists, if it doesn't there is no module
    if not r7_raw['data']:
        #No modulde exists
        r7_parsed['Module'] = "None"
    else:
        #Module(s) exist
        for module in r7_raw['data']:
            r7_parsed['Module'] = module['identifier']
            module_ctr +=1
        module_ctr = 0
    return r7_parsed


def output_for_reporting(cves):
    """
    This function is used when no output document argument is given. The
    ordered CVEs (top 10 if there are more than 10) are outputted to the terminal.
    This is for easy copy-paste from the terminal to a Detailed Findings table 
    in a report. 
    """

    ctr = 0
    #This function is run if the -o flag is not set. The script will just output the top 10 CVEs for easy copy-paste for reporting
    for entry in cves:
        #Either reaches the end of the list or stops at 10
        if ctr == 9 or ctr == (len(cves)-1):
            print(entry['CVE'])
            break
        else:
            print(entry['CVE'], ", ", end="", sep="")
            ctr +=1

def output_report_yaml(cves): 
    """
    This function is used when an output YAML file is specified as an argument. 
    The function dumps all ordered CVEs and their data into a YAML file. The 
    purpose of this is for assist pen testers in identifying CVEs with high 
    CVSS scores, and having quick reference for any exploits that may exist.
    """
    filename = args.output
    with open(filename, 'w') as file:
        documents = yaml.dump(cves, file)
    print("Output File Created")

def output_report_csv(cves): 
    """
    This function is used when an output CSV file is specified as an argument. 
    The function dumps all ordered CVEs and their data into a CSV file. The 
    purpose of this is for assist pen testers in identifying CVEs with high 
    CVSS scores, and having quick reference for any exploits that may exist.
    """
    filename = args.output
    keys = cves[0].keys()

    with open(filename, 'w') as file:
        documents = csv.DictWriter(file, keys)
        documents.writeheader()
        documents.writerows(cves)
    print("Output File Created")
    
# Prepwork

with open(args.input.strip(), 'r') as input_file:
    cveList = input_file.read().splitlines()

# Main

if __name__ == "__main__":

    count = 0
    cve_list = []
    for cve in cveList:
        # check if CVE is properly written
        if not re.match("^CVE-[0-9]{4}-[0-9]+$", cve):
            print("Error! CVE: {cve} not valid, skipping")
            continue
        count +=1
        time.sleep(sleepTime)

        nvd_output,r7_output = cve_query(cve)
        nvd_info = parse_nvd(nvd_output)
        r7_info = parse_r7(r7_output)
        cve_info = nvd_info | r7_info
        cve_list.append(cve_info)

    """
    A good one-liner for sorting the list of CVEs. CVEs are ordered by their CVSS Score,
    Number of Exploits, and finally by how new they are. This is where the Number of exploits, 
    Year and Number values from the nvd_parse function come into play.
    """ 
    cve_list = sorted(cve_list, key=lambda d: (d['Score'], d['Number_of_Exploits'], d['Year'], d['Number']), reverse=True)

    #Remove superflous information that was used for sorting
    for vuln in cve_list:
        del vuln['Year']
        del vuln['Number']
        del vuln['Number_of_Exploits']

    if args.output is not None:
        if re.search("(\.[^-]*)", args.output).group(0) == ".yaml":
            output_report_yaml(cve_list)
        elif  re.search("(\.[^-]*)", args.output).group(0) == ".csv":
            output_report_csv(cve_list)
        else:
            print("Please chooe a CSV or YAML file as an output.")
    else:
        #No output, output for just reporting
        output_for_reporting(cve_list)

        
        




